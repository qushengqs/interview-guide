- 使用上的区别
  - volatile只能用于修饰实例变量或者类变量，不能用于修饰方法以及方法参数和局部变量、常量等
  - synchronized不能用于对变量的修饰，只能用于修饰方法或者语句块
  - volatile修饰的变量可以为null，synchronized关键字同步语句块的monitor对象不能为null
- 原子性的保证
  - volatile无法保证原子性
  - synchronized是一种排他机制，因此同步代码是无法被中途打断的，可以保证原子性
- 可见性的保证
  - 都可以保证共享资源在多线程间的可见性，但实现的机制完全不同
  - synchronized借助于JVM指令monitor enter和monitor exit对通过排他的方式使得同步代码串行化，在monitor exit时所有共享资源都将会被刷新到主内存中
  - volatile使用机器指令“lock:”方式迫使其他线程工作内存中的数据失效，不得不到主内存中进行再次加载
- 有序性的保证
  - volatile禁止JVM编译器以及处理器对其进行重排序
  - synchronized是以程序的串行化来保证有序性
- 其他
  - volatile不会使线程陷入阻塞
  - synchronized会使线程进入阻塞状态